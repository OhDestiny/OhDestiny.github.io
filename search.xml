<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>浅析python中的深浅拷贝</title>
      <link href="/2024/07/22/%E6%B5%85%E6%9E%90python%E4%B8%AD%E7%9A%84%E6%B7%B1%E6%B5%85%E6%8B%B7%E8%B4%9D/"/>
      <url>/2024/07/22/%E6%B5%85%E6%9E%90python%E4%B8%AD%E7%9A%84%E6%B7%B1%E6%B5%85%E6%8B%B7%E8%B4%9D/</url>
      
        <content type="html"><![CDATA[<h1 id="深浅拷贝"><a href="#深浅拷贝" class="headerlink" title="深浅拷贝"></a>深浅拷贝</h1><h2 id="问题抛出"><a href="#问题抛出" class="headerlink" title="问题抛出"></a>问题抛出</h2><p>对于下边这段代码，使用三种形式创建dict_test的临时变量tmp，并且修改tmp的值，输出原来变量和tmp变量，三种形式有什么不同，分别执行修改后，<br>最后三个print的值是多少。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> copy <span class="keyword">import</span> deepcopy</span><br><span class="line">dict_test = &#123;<span class="string">&quot;name&quot;</span>: <span class="string">&quot;ruby&quot;</span>, <span class="string">&quot;list&quot;</span>: [<span class="number">1</span>, <span class="number">2</span>]&#125;</span><br><span class="line"></span><br><span class="line">tmp1 = dict_test</span><br><span class="line">tmp2 = dict_test.copy()</span><br><span class="line">tmp3 = deepcopy(dict_test)</span><br><span class="line"></span><br><span class="line">tmp1[<span class="string">&quot;name&quot;</span>] = <span class="string">&quot;leo&quot;</span></span><br><span class="line">tmp1[<span class="string">&quot;list&quot;</span>][<span class="number">0</span>] = <span class="number">10</span></span><br><span class="line"></span><br><span class="line">tmp2[<span class="string">&quot;name&quot;</span>] = <span class="string">&quot;leo&quot;</span></span><br><span class="line">tmp2[<span class="string">&quot;list&quot;</span>][<span class="number">0</span>] = <span class="number">10</span></span><br><span class="line"></span><br><span class="line">tmp3[<span class="string">&quot;name&quot;</span>] = <span class="string">&quot;leo&quot;</span></span><br><span class="line">tmp3[<span class="string">&quot;list&quot;</span>][<span class="number">0</span>] = <span class="number">10</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(tmp1, dict_test)  <span class="comment"># &#123;&#x27;name&#x27;: &#x27;leo&#x27;, &#x27;list&#x27;: [10, 2]&#125; &#123;&#x27;name&#x27;: &#x27;leo&#x27;, &#x27;list&#x27;: [10, 2]&#125;</span></span><br><span class="line"><span class="built_in">print</span>(tmp2, dict_test)  <span class="comment"># &#123;&#x27;name&#x27;: &#x27;leo&#x27;, &#x27;list&#x27;: [10, 2]&#125; &#123;&#x27;name&#x27;: &#x27;ruby&#x27;, &#x27;list&#x27;: [10, 2]&#125;</span></span><br><span class="line"><span class="built_in">print</span>(tmp3, dict_test)  <span class="comment"># &#123;&#x27;name&#x27;: &#x27;leo&#x27;, &#x27;list&#x27;: [10, 2]&#125; &#123;&#x27;name&#x27;: &#x27;ruby&#x27;, &#x27;list&#x27;: [1, 2]&#125;</span></span><br></pre></td></tr></table></figure><h2 id="答案解析"><a href="#答案解析" class="headerlink" title="答案解析"></a>答案解析</h2><hr><p>答案:</p><p>{‘name’: ‘leo’, ‘list’: [10, 2]} {‘name’: ‘leo’, ‘list’: [10, 2]}</p><p>{‘name’: ‘leo’, ‘list’: [10, 2]} {‘name’: ‘ruby’, ‘list’: [10, 2]}</p><p>{‘name’: ‘leo’, ‘list’: [10, 2]} {‘name’: ‘ruby’, ‘list’: [1, 2]}</p><hr><h3 id="1-tmp1-dict-test"><a href="#1-tmp1-dict-test" class="headerlink" title="1. tmp1 &#x3D; dict_test"></a>1. tmp1 &#x3D; dict_test</h3><p>这行代码将 dict_test 赋值给 tmp1。这意味着 tmp1 和 dict_test 是同一个字典对象的两个引用。 而字典对象可变变量，所以修改新的字典对象会直接影响旧的字典对象的所有元素。</p><h3 id="2-tmp2-dict-test-copy"><a href="#2-tmp2-dict-test-copy" class="headerlink" title="2. tmp2 &#x3D; dict_test.copy()"></a>2. tmp2 &#x3D; dict_test.copy()</h3><p>使用copy函数创建原始对象的浅拷贝，并将其赋值给tmp，浅拷贝会创建一个新的对象，并且将原始对象的值赋值给新的对象，但是<br>，只是将引用赋值给了新的对象，所以对于原始字典对象中的不可变数据，比如字符串来说，修改新的对象的值不会影响原始字典对象的值，但是对于可变<br>数据类型列表来说，修改新的字典对象中的列表就会影响到旧的字典对象中的列表。</p><h3 id="3-tmp3-deepcopy-dict-test"><a href="#3-tmp3-deepcopy-dict-test" class="headerlink" title="3. tmp3 &#x3D; deepcopy(dict_test)"></a>3. tmp3 &#x3D; deepcopy(dict_test)</h3><p>使用deepcopy创建了原始字典对象的深拷贝，并且将原始字典的值全部赋值给新的字典对象，<br>新对象和原始对象完全独立，修改新对象的值不会影响原始字典对象的值</p><p>那么对于上边提到的可变数据类型和不可变数据类型有什么区别？</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">+ 不可变类型（如整数、浮点数、字符串、元组）：一旦创建，其内容不能被修改。当你对一个不可变类型的变量进行操作时，实际上是在创建一个新的对象，并将变量指向这个新对象。</span><br><span class="line">+ 可变类型（如列表、字典、集合）：其内容可以被修改。当你对一个可变类型的变量进行操作时，你实际上是在修改原有的对象。</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>使用&#x3D;操作，修改新对象的任意元素，都会修改原对象的相应元素</li><li>使用浅拷贝，修改新对象的不可变数据类型的元素，原对象不会发生改变，但是修改新对象的可变数据类型的元素，原对象也会发生变化</li><li>使用深拷贝可以创建与原对象完全独立的副本，无论修改什么，都不会影响原对象</li></ul>]]></content>
      
      
      <categories>
          
          <category> python基础语法小细节 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浅析python中的按位与和逻辑与</title>
      <link href="/2024/07/19/%E6%B5%85%E6%9E%90python%E4%B8%AD%E7%9A%84%E6%8C%89%E4%BD%8D%E4%B8%8E%E5%92%8C%E9%80%BB%E8%BE%91%E4%B8%8E/"/>
      <url>/2024/07/19/%E6%B5%85%E6%9E%90python%E4%B8%AD%E7%9A%84%E6%8C%89%E4%BD%8D%E4%B8%8E%E5%92%8C%E9%80%BB%E8%BE%91%E4%B8%8E/</url>
      
        <content type="html"><![CDATA[<h1 id="and与-的区别"><a href="#and与-的区别" class="headerlink" title="and与&amp;的区别"></a>and与&amp;的区别</h1><h2 id="1-问题抛出"><a href="#1-问题抛出" class="headerlink" title="1. 问题抛出"></a>1. 问题抛出</h2><p>首先,给出一个问题,下边这段代码输出的内容是什么:</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">res1 = <span class="number">2</span> <span class="keyword">and</span> <span class="number">5</span> </span><br><span class="line">res1_contrast_one = <span class="number">5</span> <span class="keyword">and</span> <span class="number">2</span></span><br><span class="line">res1_contrast_two = <span class="number">5</span> &amp; <span class="number">2</span></span><br><span class="line"></span><br><span class="line">res3 = <span class="number">1</span> &gt;= <span class="number">0</span> <span class="keyword">and</span> -<span class="number">1</span> &gt;= <span class="number">0</span></span><br><span class="line">res4 = (<span class="number">1</span> &gt;= <span class="number">0</span>) &amp; (-<span class="number">1</span> &gt;= <span class="number">0</span>)</span><br><span class="line">res5 = <span class="number">1</span> &gt;= <span class="number">0</span> &amp; -<span class="number">1</span> &gt;= <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(res1, res1_contrast_one, res1_contrast_two, res3, res4, res5)</span><br></pre></td></tr></table></figure><h2 id="2-答案解析"><a href="#2-答案解析" class="headerlink" title="2. 答案解析"></a>2. 答案解析</h2><hr><p>答案揭晓: 5 2 0 False False True</p><hr><p>解释：</p><ol><li>&amp;和and这两个运算符是两种不一样的运算符，&amp;表示按位与，而and表示逻辑与</li><li>逻辑与: 不为0，’’, none的值都认为是True，都是如果符号两边都是不为0的值，则为True，并且and会返回最后一个值</li><li>按位与: 如果是整数,则直接进行位运算。</li><li>&amp;和and这两个运算符的运算顺序也不一样，在python中，() &gt; &amp; &gt; 比较运算符 &gt; and</li></ol><ul><li>有了以上知识点，就很好理解了，<ul><li>res1 表达式的and两边都是True，返回后边的5</li><li>res1_contrast_one返回后边的2</li><li>5&amp;2 5: 101 2:010 刚好与完归零了</li></ul></li><li>而后边三个，就涉及到运算顺序了:<ul><li>res3: 先比较运算符,左边是True,右边是False,则返回False</li><li>res4: 先算小括号的,左边是True,右边是False,则返回False</li><li>res5: 先算按位与&amp;,0&amp;-1 显然是0, 1&gt;&#x3D;0&gt;&#x3D;0 为True</li></ul></li></ul><h2 id="3-总结"><a href="#3-总结" class="headerlink" title="3. 总结"></a>3. 总结</h2><p>开发过程中，主要注意两点:</p><ol><li>and和&amp;是不一样的，一个是逻辑与，一个是按位与</li><li>and和&amp;的运算顺序也是不一样的，并且() &gt; &amp; &gt; 比较运算符 &gt; and</li></ol>]]></content>
      
      
      <categories>
          
          <category> python基础语法小细节 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
