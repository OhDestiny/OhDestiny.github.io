<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>ctfshow_OneToTen</title>
      <link href="/2024/08/12/ctfshow-OneToTen/"/>
      <url>/2024/08/12/ctfshow-OneToTen/</url>
      
        <content type="html"><![CDATA[<h1 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h1><h2 id="1-前端的html代码的注释泄露信息"><a href="#1-前端的html代码的注释泄露信息" class="headerlink" title="1 前端的html代码的注释泄露信息"></a>1 前端的html代码的注释泄露信息</h2><p>有的时候，如果程序员没有足够的安全意识，可能部署站点的时候会直接将含有敏感信息的代码部署上去，我们需要去查看相应的代码，发现潜在的敏感信息，这道ctf也是如此，直接右键检查网页，即可获取注释中未删除的flag<br><img src="https://iwbtfy-photos.oss-cn-beijing.aliyuncs.com/ctfshow/oneToTen/ctfshow_one_1.png"></p><h2 id="2-前端拦截不让右键打开检查，ctrl-shift-i-快捷键-浏览器右上角的工具栏"><a href="#2-前端拦截不让右键打开检查，ctrl-shift-i-快捷键-浏览器右上角的工具栏" class="headerlink" title="2 前端拦截不让右键打开检查，ctrl+shift+i 快捷键 &#x2F; 浏览器右上角的工具栏"></a>2 前端拦截不让右键打开检查，ctrl+shift+i 快捷键 &#x2F; 浏览器右上角的工具栏</h2><p>这个题和上一个题类似，也是将flag藏在了注释之中，但是不同的地方是这个前台js设置了不能右键，那么我们选择直接快捷键或者是浏览器右上方的工具栏即可。</p><h2 id="3-抓包-flag藏于数据包中"><a href="#3-抓包-flag藏于数据包中" class="headerlink" title="3 抓包 flag藏于数据包中"></a>3 抓包 flag藏于数据包中</h2><p>数据包也是一个信息比较多的地方，我们需要仔细检查站点的数据包，可能会有意想不到的收获，这个题目也是这样，右键检查，选择网络，刷新界面，打开数据包，可以看到数据包中存在flag字段<br><img src="https://iwbtfy-photos.oss-cn-beijing.aliyuncs.com/ctfshow/oneToTen/ctfshow_three_1.png"></p><h2 id="4-robots-txt-文件"><a href="#4-robots-txt-文件" class="headerlink" title="4 robots.txt 文件"></a>4 robots.txt 文件</h2><ul><li>robots.txt 文件是一个纯文本文件，在这个文件中网站管理者可以声明该网站中不想被robots访问的部分，或者指定搜索引擎只收录指定的内容。robots.txt文件只能放在一个站点的根目录下。</li><li>当一个搜索机器人访问一个站点的时候，首先会检查该站点根目录下是否存在robots.txt文件，如果存在的话，搜索机器人就会按照该文件中的内容来确定访问的范围，如果这个文件不存在，那么搜索机器人就沿着链接抓取。</li></ul><p>下边是一个robots.txt文件的示例:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">User-agent: *</span><br><span class="line">Disallow: /flagishere.txt</span><br></pre></td></tr></table></figure><p>对于这个ctf题目:</p><ul><li>扫描目录，发现存在robots.txt文件，查看文件内容，发现目录flagishere.txt</li></ul><p><img src="https://iwbtfy-photos.oss-cn-beijing.aliyuncs.com/ctfshow/oneToTen/ctfshow_four_1.png"></p><ul><li>访问&#x2F;flagishere.txt, 获取flag</li></ul><p><img src="https://iwbtfy-photos.oss-cn-beijing.aliyuncs.com/ctfshow/oneToTen/ctfshow_four_2.png"></p><h2 id="5-php源码的泄露"><a href="#5-php源码的泄露" class="headerlink" title="5 php源码的泄露"></a>5 php源码的泄露</h2><p>.phps后缀文件: php source 即php的原始文件，使用phps文件可以看到对应php文件的实际源码内容。</p><p>扫描目录，发现存在index.phps文件，直接下载打开发现flag就在其中:<br><img src="https://iwbtfy-photos.oss-cn-beijing.aliyuncs.com/ctfshow/oneToTen/ctfshow_five_1.png"></p><h2 id="6-网站部署的时候，直接解压源码但是没有删除源码"><a href="#6-网站部署的时候，直接解压源码但是没有删除源码" class="headerlink" title="6 网站部署的时候，直接解压源码但是没有删除源码"></a>6 网站部署的时候，直接解压源码但是没有删除源码</h2><h3 id="扫描目录-发现www-zip"><a href="#扫描目录-发现www-zip" class="headerlink" title="扫描目录 发现www.zip"></a>扫描目录 发现<a href="http://www.zip/">www.zip</a></h3><h3 id="解压直接发现fl000g-txt文件-直接拿到flag"><a href="#解压直接发现fl000g-txt文件-直接拿到flag" class="headerlink" title="解压直接发现fl000g.txt文件 直接拿到flag"></a>解压直接发现fl000g.txt文件 直接拿到flag</h3><p><img src="https://iwbtfy-photos.oss-cn-beijing.aliyuncs.com/ctfshow/oneToTen/%E6%BA%90%E7%A0%81%E6%B2%A1%E5%88%A0.png"></p><h2 id="7-版本控制文件-git-残留"><a href="#7-版本控制文件-git-残留" class="headerlink" title="7 版本控制文件.git 残留"></a>7 版本控制文件.git 残留</h2><p>版本控制文件.git文件部署的时候没有删除，可以通过版本控制文件还原站点源码，导致源码泄露。</p><p><img src="https://iwbtfy-photos.oss-cn-beijing.aliyuncs.com/ctfshow/oneToTen/ctfshow_seven_1.png"></p><h2 id="8-版本控制文件-svn-残留"><a href="#8-版本控制文件-svn-残留" class="headerlink" title="8 版本控制文件.svn 残留"></a>8 版本控制文件.svn 残留</h2><p>版本控制文件.svn文件部署的时候没有删除，可以通过版本控制文件还原站点源码，导致源码泄露。</p><p><img src="https://iwbtfy-photos.oss-cn-beijing.aliyuncs.com/ctfshow/oneToTen/ctfshow_eight_1.png"></p><h2 id="9-swp文件"><a href="#9-swp文件" class="headerlink" title="9 .swp文件"></a>9 .swp文件</h2><p>vim编辑器使用时会有一个缓存文件，这个缓存文件在保存时进行删除，但是在vim意外退出时这个缓存文件，会以源文件加一个.swp后缀进行保存，我们可以尝试访问这些文件来尝试获取一些文件。</p><h2 id="10-cookie里边也有可能有惊喜哦"><a href="#10-cookie里边也有可能有惊喜哦" class="headerlink" title="10 cookie里边也有可能有惊喜哦"></a>10 cookie里边也有可能有惊喜哦</h2><p>这题就是将flag存放在了cookie里边，所以我们只需要知道cookie的位置即可。</p>]]></content>
      
      
      <categories>
          
          <category> ctfshow </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 信息收集，web安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浅析python中的深浅拷贝</title>
      <link href="/2024/07/22/%E6%B5%85%E6%9E%90python%E4%B8%AD%E7%9A%84%E6%B7%B1%E6%B5%85%E6%8B%B7%E8%B4%9D/"/>
      <url>/2024/07/22/%E6%B5%85%E6%9E%90python%E4%B8%AD%E7%9A%84%E6%B7%B1%E6%B5%85%E6%8B%B7%E8%B4%9D/</url>
      
        <content type="html"><![CDATA[<h1 id="深浅拷贝"><a href="#深浅拷贝" class="headerlink" title="深浅拷贝"></a>深浅拷贝</h1><h2 id="问题抛出"><a href="#问题抛出" class="headerlink" title="问题抛出"></a>问题抛出</h2><p>对于下边这段代码，使用三种形式创建dict_test的临时变量tmp，并且修改tmp的值，输出原来变量和tmp变量，三种形式有什么不同，分别执行修改后，最后三个print的值是多少。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> copy <span class="keyword">import</span> deepcopy</span><br><span class="line">dict_test = &#123;<span class="string">&quot;name&quot;</span>: <span class="string">&quot;ruby&quot;</span>, <span class="string">&quot;list&quot;</span>: [<span class="number">1</span>, <span class="number">2</span>]&#125;</span><br><span class="line"></span><br><span class="line">tmp1 = dict_test</span><br><span class="line">tmp2 = dict_test.copy()</span><br><span class="line">tmp3 = deepcopy(dict_test)</span><br><span class="line"></span><br><span class="line">tmp1[<span class="string">&quot;name&quot;</span>] = <span class="string">&quot;leo&quot;</span></span><br><span class="line">tmp1[<span class="string">&quot;list&quot;</span>][<span class="number">0</span>] = <span class="number">10</span></span><br><span class="line"></span><br><span class="line">tmp2[<span class="string">&quot;name&quot;</span>] = <span class="string">&quot;leo&quot;</span></span><br><span class="line">tmp2[<span class="string">&quot;list&quot;</span>][<span class="number">0</span>] = <span class="number">10</span></span><br><span class="line"></span><br><span class="line">tmp3[<span class="string">&quot;name&quot;</span>] = <span class="string">&quot;leo&quot;</span></span><br><span class="line">tmp3[<span class="string">&quot;list&quot;</span>][<span class="number">0</span>] = <span class="number">10</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(tmp1, dict_test)  <span class="comment"># &#123;&#x27;name&#x27;: &#x27;leo&#x27;, &#x27;list&#x27;: [10, 2]&#125; &#123;&#x27;name&#x27;: &#x27;leo&#x27;, &#x27;list&#x27;: [10, 2]&#125;</span></span><br><span class="line"><span class="built_in">print</span>(tmp2, dict_test)  <span class="comment"># &#123;&#x27;name&#x27;: &#x27;leo&#x27;, &#x27;list&#x27;: [10, 2]&#125; &#123;&#x27;name&#x27;: &#x27;ruby&#x27;, &#x27;list&#x27;: [10, 2]&#125;</span></span><br><span class="line"><span class="built_in">print</span>(tmp3, dict_test)  <span class="comment"># &#123;&#x27;name&#x27;: &#x27;leo&#x27;, &#x27;list&#x27;: [10, 2]&#125; &#123;&#x27;name&#x27;: &#x27;ruby&#x27;, &#x27;list&#x27;: [1, 2]&#125;</span></span><br></pre></td></tr></table></figure><h2 id="答案解析"><a href="#答案解析" class="headerlink" title="答案解析"></a>答案解析</h2><hr><p>答案:</p><p>{‘name’: ‘leo’, ‘list’: [10, 2]} {‘name’: ‘leo’, ‘list’: [10, 2]}</p><p>{‘name’: ‘leo’, ‘list’: [10, 2]} {‘name’: ‘ruby’, ‘list’: [10, 2]}</p><p>{‘name’: ‘leo’, ‘list’: [10, 2]} {‘name’: ‘ruby’, ‘list’: [1, 2]}</p><hr><h3 id="1-tmp1-dict-test"><a href="#1-tmp1-dict-test" class="headerlink" title="1. tmp1 &#x3D; dict_test"></a>1. tmp1 &#x3D; dict_test</h3><p>这行代码将 dict_test 赋值给 tmp1。这意味着 tmp1 和 dict_test 是同一个字典对象的两个引用。 而字典对象可变变量，所以修改新的字典对象会直接影响旧的字典对象的所有元素。</p><h3 id="2-tmp2-dict-test-copy"><a href="#2-tmp2-dict-test-copy" class="headerlink" title="2. tmp2 &#x3D; dict_test.copy()"></a>2. tmp2 &#x3D; dict_test.copy()</h3><p>使用copy函数创建原始对象的浅拷贝，并将其赋值给tmp，浅拷贝会创建一个新的对象，并且将原始对象的值赋值给新的对象，但是，只是将引用赋值给了新的对象，所以对于原始字典对象中的不可变数据，比如字符串来说，修改新的对象的值不会影响原始字典对象的值，但是对于可变数据类型列表来说，修改新的字典对象中的列表就会影响到旧的字典对象中的列表。</p><h3 id="3-tmp3-deepcopy-dict-test"><a href="#3-tmp3-deepcopy-dict-test" class="headerlink" title="3. tmp3 &#x3D; deepcopy(dict_test)"></a>3. tmp3 &#x3D; deepcopy(dict_test)</h3><p>使用deepcopy创建了原始字典对象的深拷贝，并且将原始字典的值全部赋值给新的字典对象，新对象和原始对象完全独立，修改新对象的值不会影响原始字典对象的值</p><p>那么对于上边提到的可变数据类型和不可变数据类型有什么区别？</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">+ 不可变类型（如整数、浮点数、字符串、元组）：一旦创建，其内容不能被修改。当你对一个不可变类型的变量进行操作时，实际上是在创建一个新的对象，并将变量指向这个新对象。</span><br><span class="line">+ 可变类型（如列表、字典、集合）：其内容可以被修改。当你对一个可变类型的变量进行操作时，你实际上是在修改原有的对象。</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>使用&#x3D;操作，修改新对象的任意元素，都会修改原对象的相应元素</li><li>使用浅拷贝，修改新对象的不可变数据类型的元素，原对象不会发生改变，但是修改新对象的可变数据类型的元素，原对象也会发生变化</li><li>使用深拷贝可以创建与原对象完全独立的副本，无论修改什么，都不会影响原对象</li></ul>]]></content>
      
      
      <categories>
          
          <category> python基础语法小细节 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浅析python中的按位与和逻辑与</title>
      <link href="/2024/07/19/%E6%B5%85%E6%9E%90python%E4%B8%AD%E7%9A%84%E6%8C%89%E4%BD%8D%E4%B8%8E%E5%92%8C%E9%80%BB%E8%BE%91%E4%B8%8E/"/>
      <url>/2024/07/19/%E6%B5%85%E6%9E%90python%E4%B8%AD%E7%9A%84%E6%8C%89%E4%BD%8D%E4%B8%8E%E5%92%8C%E9%80%BB%E8%BE%91%E4%B8%8E/</url>
      
        <content type="html"><![CDATA[<h1 id="and与-的区别"><a href="#and与-的区别" class="headerlink" title="and与&amp;的区别"></a>and与&amp;的区别</h1><h2 id="1-问题抛出"><a href="#1-问题抛出" class="headerlink" title="1. 问题抛出"></a>1. 问题抛出</h2><p>首先,给出一个问题,下边这段代码输出的内容是什么:</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">res1 = <span class="number">2</span> <span class="keyword">and</span> <span class="number">5</span> </span><br><span class="line">res1_contrast_one = <span class="number">5</span> <span class="keyword">and</span> <span class="number">2</span></span><br><span class="line">res1_contrast_two = <span class="number">5</span> &amp; <span class="number">2</span></span><br><span class="line"></span><br><span class="line">res3 = <span class="number">1</span> &gt;= <span class="number">0</span> <span class="keyword">and</span> -<span class="number">1</span> &gt;= <span class="number">0</span></span><br><span class="line">res4 = (<span class="number">1</span> &gt;= <span class="number">0</span>) &amp; (-<span class="number">1</span> &gt;= <span class="number">0</span>)</span><br><span class="line">res5 = <span class="number">1</span> &gt;= <span class="number">0</span> &amp; -<span class="number">1</span> &gt;= <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(res1, res1_contrast_one, res1_contrast_two, res3, res4, res5)</span><br></pre></td></tr></table></figure><h2 id="2-答案解析"><a href="#2-答案解析" class="headerlink" title="2. 答案解析"></a>2. 答案解析</h2><hr><p>答案揭晓: 5 2 0 False False True</p><hr><p>解释：</p><ol><li>&amp;和and这两个运算符是两种不一样的运算符，&amp;表示按位与，而and表示逻辑与</li><li>逻辑与: 不为0，’’, none的值都认为是True，都是如果符号两边都是不为0的值，则为True，并且and会返回最后一个值</li><li>按位与: 如果是整数,则直接进行位运算。</li><li>&amp;和and这两个运算符的运算顺序也不一样，在python中，() &gt; &amp; &gt; 比较运算符 &gt; and</li></ol><ul><li>有了以上知识点，就很好理解了，<ul><li>res1 表达式的and两边都是True，返回后边的5</li><li>res1_contrast_one返回后边的2</li><li>5&amp;2 5: 101 2:010 刚好与完归零了</li></ul></li><li>而后边三个，就涉及到运算顺序了:<ul><li>res3: 先比较运算符,左边是True,右边是False,则返回False</li><li>res4: 先算小括号的,左边是True,右边是False,则返回False</li><li>res5: 先算按位与&amp;,0&amp;-1 显然是0, 1&gt;&#x3D;0&gt;&#x3D;0 为True</li></ul></li></ul><h2 id="3-总结"><a href="#3-总结" class="headerlink" title="3. 总结"></a>3. 总结</h2><p>开发过程中，主要注意两点:</p><ol><li>and和&amp;是不一样的，一个是逻辑与，一个是按位与</li><li>and和&amp;的运算顺序也是不一样的，并且() &gt; &amp; &gt; 比较运算符 &gt; and</li></ol>]]></content>
      
      
      <categories>
          
          <category> python基础语法小细节 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
